[ { "title": "HTTP 완벽가이드를 읽고", "url": "/posts/http-definitive-guide/", "categories": "book, http", "tags": "http", "date": "2021-06-15 00:00:00 +0900", "snippet": "HTTP (Hypertext Transfer Porotocol)웹에서 클라이언트와 서버가 데이터를 주고받는 방식으로 현대 인터넷에 공용어라고 말할 수 있다.웹 클라이언트가 웹 서버에서 요청 → 웹 서버가 웹 클라이언트에게 응답이 하나의 HTTP 트랜잭션이다.MIME웹 클라이언트가 서버에게 요청하는 리소스는 html, txt, jpeg, avi 등 수많은 종류가 있고 이것들을 MIME(Multipurpose Internet Mail Extensions)라는 라벨을 붙여 구분한다.MIME 은 주 타입/부 타입 으로 구성된 문자열이..." }, { "title": "애플 보상판매와 M1 Macbook Air 구매", "url": "/posts/m1-macbook-air-with-tradein/", "categories": "hardware, apple", "tags": "apple, macbook, m1, tradein", "date": "2021-06-01 00:00:00 +0900", "snippet": "2014년 처음으로 개발을 시작하면서 구매했던 맥북 프로 13인치.. 지금까지 6년간 잘 써왔지만 이젠 보내줄때가 됐다 M1 맥북에어가 역대급으로 평가가 좋아서 고민끝에 결국 온라인 애플스토어에서 주문을 했는데 기존 사용중인 구형 맥북을 보상판매 할 수 있었다맥북 일련번호와 몇가지 질문에 답변만 하면 바로 예상매입가가 나온다. 오래된 맥북이라 얼마 못받을거라 생각했는데생각보다 많이 준다.덕분에 M1 맥북에어를 겨우 79만원에 살 수 있게 됐다👍 (교육할인까지 받는 사람은 여기서 13만원 더 싸게 살 수가 있다.)바로 보상판매 ..." }, { "title": "드럼 커버 - 위대한 쇼맨", "url": "/posts/drum-cover-thisisme/", "categories": "hobby, drum", "tags": "drum, cover, video", "date": "2020-12-15 00:00:00 +0900", "snippet": "The Greatest Showman - This is me드럼을 치지않은지 엄청 오래 됐고 앞으로도 드럼칠 일은 없을거지만, 영상을 하나 남겨놓고 싶었다.지훈이형이 연습실도 빌려주고 영상편집도 해줬다. 감사👋" }, { "title": "IOS 빌드 과정", "url": "/posts/ios-build-process/", "categories": "build, ios", "tags": "ios, build, certificate, provisioning profile, code sign", "date": "2020-06-03 00:00:00 +0900", "snippet": "OpenSSL commands// plain textecho Hello, IOS! &amp;gt;&amp;gt; test.txt// hashopenssl dgst -sha256 test.txt &amp;gt;&amp;gt; test.hash// .p12 -&amp;gt; pemopenssl pkcs12 -in privatekey.p12 -out privatekey.pem -nodes// get publickey &amp;amp; info from CSRopenssl req -in CertificateSigningRequest...." }, { "title": "Unity와 Android 네이티브 플러그인 (Unity - Android Native Plugin)", "url": "/posts/unity-aos-native-plugin/", "categories": "unity, plugin", "tags": "unity, android, native", "date": "2020-05-17 00:00:00 +0900", "snippet": "유니티 씬AOSManager라는 이름의 게임오브젝트와 스크립트가 있고 이벤트를 받을 버튼 2개 생성했다Get Battery는 디바이스의 남은 배터리를 가져오는 기능, Open Web Page는 해당 URL을 웹뷰로 여는 기능이며 Android 네이티브에서 작성된 코드로 동작한다유니티 C# 코드AndroidJavaObject 라는 유니티에서 제공하는 헬퍼클래스를 사용해서 실행중인 액티비티 객체를 받아온다com.unity3d.player.UnityPlayer클래스는 자바프로젝트로 익스포트했을때 유니티에서 자동으로 만들어주는 코드인..." }, { "title": "Unity와 IOS 네이티브 플러그인 (Unity - IOS Native Plugin)", "url": "/posts/unity-ios-native-plugin/", "categories": "unity, plugin", "tags": "unity, ios, native", "date": "2020-05-16 00:00:00 +0900", "snippet": "유니티 씬IOSManager라는 이름의 게임오브젝트와 스크립트가 있고 이벤트를 받을 버튼 2개 생성했다Get Battery는 디바이스의 남은 배터리를 가져오는 기능, Open Web Page는 해당 URL을 웹뷰로 여는 기능이며 IOS 네이티브에서 작성된 코드로 동작한다유니티 C# 코드[DllImport(“__Internal”)] 선언으로 IOS네이티브쪽에 extern으로 정의될 함수이름과 매개변수를 적어준다IOS쪽에서 실행된 결과를 다시 유니티에서 받을수 있도록 ReceiveFromNativeGetBattery (string..." }, { "title": "소스트리-깃랩 연동하기 (SSH)", "url": "/posts/sourcetree-with-gitlab-ssh/", "categories": "git, sorcetree", "tags": "sourcetree, gitlab, ssh", "date": "2020-05-10 00:00:00 +0900", "snippet": "터미널에서 SSH 키 생성$ ssh-keygen -t rsa 입력하면 저장경로와 비밀번호를 설정한다아무입력없이 엔터만 누르면 기본경로에 비밀번호없이 생성되지만 보안상 비밀번호는 설정해주도록 하자$ Enter file in which to save the key (/Users/계정/.ssh/id_rsa): &amp;lt;저장 경로&amp;gt;$ Enter passphrase (empty for no passphrase): &amp;lt;비밀번호 입력&amp;gt;$ Enter same passphrase again: &amp..." }, { "title": "소스트리-깃랩 연동하기 (HTTPS)", "url": "/posts/sourcetree-with-gitlab-https/", "categories": "git, sorcetree", "tags": "sourcetree, gitlab, https", "date": "2020-05-09 00:00:00 +0900", "snippet": "GitLab 웹페이지에서 오른쪽상단 프로필이미지클릭 - Settings왼쪽 메뉴에서 Access Tokens - 이름과 권한설정 - Create personal access token 버튼 클릭생성된 Access Token 복사SourceTree 실행 - 설정GitLab 이름과 복사한 Access Token 붙여넣기 이름은 자신의 프로필에 적혀있는 이름(FullName)을 적어야한다 (Access Token 생성할때 입력한 이름이 아니다)HTTPS 프로토콜로 설정 자신의 맥 계정 비밀번호 입력GitLab 비밀번호를 입력이제 소..." }, { "title": "계수 정렬 (Counting Sort)", "url": "/posts/counting-sort/", "categories": "algorithm, sort", "tags": "counting, sort", "date": "2020-03-09 00:00:00 +0900", "snippet": "배열 내 모든 값의 중복 횟수를 세서 정렬하는 방법으로 조건부 시간복잡도 O(n)의 정렬 알고리즘 입니다0부터 배열 내 가장 큰 값까지 배열 공간을 만든 후 요소 값에 해당하는 인덱스를 증가시키기 때문에 가장 큰 값이 정렬 속도에 크게 영향을 줍니다 조건에 따라 모든 정렬 알고리즘 중 가장 빠를 수도, 가장 느릴 수도 있습니다그림 설명코드 (C++)vector&amp;lt;int&amp;gt; numbers = {4, 2, 3, 1, 2, 2, 5, 3, 5, 1};int min = 1; // 가장 작은 값(필요 조건)int ..." }, { "title": "힙 정렬 (Heap Sort)", "url": "/posts/heap-sort/", "categories": "algorithm, sort", "tags": "heap, sort", "date": "2020-03-07 00:00:00 +0900", "snippet": "최대힙 또는 최소힙을 만들며 정렬하는 방법으로 시간복잡도 O(n log n)의 정렬 알고리즘 입니다완전 이진 트리로 구성 되어야하며 최악의 경우에도 시간복잡도 O(n log n)을 보장합니다그림 설명코드 (C++)vector&amp;lt;int&amp;gt; numbers = {3, 2, 7, 4, 1, 8, 6};int size = (int)numbers.size();// 최대 힙for (int i = 1; i &amp;lt; size; i++){ int root, c = i; do { root ..." }, { "title": "병합 정렬 (Merge Sort)", "url": "/posts/merge-sort/", "categories": "algorithm, sort", "tags": "merge, sort", "date": "2020-03-04 00:00:00 +0900", "snippet": "배열 길이가 1이하가 될때까지 계속 반씩 나누고, 나뉜배열을 다시 병합하며 정렬하는 방법으로 시간복잡도 O(n log n)의 정렬 알고리즘 입니다천재 폰 노이만이 개발한 분할정복 알고리즘으로 최악의 경우에도 시간복잡도 O(n log n)을 보장합니다그림 설명코드 (C++)void Merge(vector&amp;lt;int&amp;gt;&amp;amp; numbers, vector&amp;lt;int&amp;gt;&amp;amp; temp, int start, int mid, int end){ for (int i = sta..." }, { "title": "퀵 정렬 (Quick Sort)", "url": "/posts/quick-sort/", "categories": "algorithm, sort", "tags": "quick, sort", "date": "2020-03-03 00:00:00 +0900", "snippet": "배열의 임의 원소보다 작은 값 배열과 큰 값 배열로 나누고, 나뉜 두 배열에 대해서 재귀적으로 반복하는 방법으로 평균 시간복잡도 O(n log n), 최악 시간복잡도 O(n²)의 정렬 알고리즘 입니다분할정복 알고리즘으로 같은 시간복잡도 O(n log n)를 가진 병합 정렬, 힙 정렬과 비교했을때 평균적으로 더 빠른 정렬속도를 기대할 수 있습니다그림 설명코드 (C++)void QuickSort(vector&amp;lt;int&amp;gt;&amp;amp; numbers, int pivot, int end){ if (pivo..." }, { "title": "삽입 정렬 (Insertion Sort)", "url": "/posts/insertion-sort/", "categories": "algorithm, sort", "tags": "insertion, sort", "date": "2020-03-02 00:00:00 +0900", "snippet": "이미 정렬된 배열에 자신의 위치를 찾아 들어가는 방법으로 시간복잡도 O(n²)의 비효율적인 정렬 알고리즘입니다같은 시간복잡도를 가진 거품정렬, 선택정렬과 비교했을때 숫자비교횟수가 적어서 조금 더 빠르다고 볼 수도 있지만정렬된 배열 속으로 자신의 위치를 찾아들어가며 순차적으로 값을 교환하기 때문에 복사 비용이 클경우 더 느릴 수 있습니다그림 설명코드 (C++)vector&amp;lt;int&amp;gt; numbers({3, 1, 7, 4, 6});int size = (int)numbers.size();for (int i = 1..." }, { "title": "선택 정렬 (Selection Sort)", "url": "/posts/selection-sort/", "categories": "algorithm, sort", "tags": "selection, sort", "date": "2020-02-29 00:00:00 +0900", "snippet": "주어진 배열에서 최솟값을 찾아 맨앞의 원소와 교체하는 방법으로 시간복잡도 O(n²)의 비효율적인 정렬 알고리즘입니다같은 시간복잡도를 가진 거품정렬과 비교 했을때 선택정렬이 실제로 두 원소를 교환하는 횟수가 더 적기때문에 조금 더 빠릅니다그림 설명코드 (C++)vector&amp;lt;int&amp;gt; numbers({5, 1, 7, 3, 4});int size = (int)numbers.size();for (int i = 0; i &amp;lt; size - 1; i++){ int idxMin = i; for (..." }, { "title": "거품 정렬 (Bubble Sort)", "url": "/posts/bubble-sort/", "categories": "algorithm, sort", "tags": "bubble, sort", "date": "2020-02-22 11:33:00 +0900", "snippet": "두 인접한 원소를 검사하여 정렬하는 방법으로 시간복잡도 O(n²)의 비효율적인 정렬 알고리즘입니다정렬속도가 느리지만 코드가 단순하고 쉬워서 정렬 알고리즘을 처음 접하는 사람이 공부하기 좋습니다그림 설명코드 (C++)vector&amp;lt;int&amp;gt; numbers({5, 1, 7, 3, 4});int size = (int)numbers.size();for (int i = 0; i &amp;lt; size - 1; i++){ for (int j = 0; j &amp;lt; size - i - 1; j++) ..." }, { "title": "블로그 이전", "url": "/posts/naver-blog/", "categories": "blog, post", "tags": "blog", "date": "2020-01-11 00:00:00 +0900", "snippet": "개발을 처음 시작할때부터 썼던 네이버 블로그에서 깃 블로그로 이전했다.열심히 공부했던 과거의 내가 생각난다.. 😂지금은 닫았지만 쓸만한 내용의 포스트는 새로 정리해서 깃 블로그로 옮겨와야겠다." } ]
